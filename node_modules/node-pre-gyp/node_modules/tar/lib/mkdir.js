'use strict'
// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = require('mkdirp')
const fs = require('fs')
const path = require('path')
const chownr = require('chownr')
<<<<<<< HEAD
const normPath = require('./normalize-windows-path.js')
=======
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93

class SymlinkError extends Error {
  constructor (symlink, path) {
    super('Cannot extract through symbolic link')
    this.path = path
    this.symlink = symlink
  }

  get name () {
    return 'SylinkError'
  }
}

class CwdError extends Error {
  constructor (path, code) {
    super(code + ': Cannot cd into \'' + path + '\'')
    this.path = path
    this.code = code
  }

  get name () {
    return 'CwdError'
  }
}

<<<<<<< HEAD
const cGet = (cache, key) => cache.get(normPath(key))
const cSet = (cache, key, val) => cache.set(normPath(key), val)

const checkCwd = (dir, cb) => {
  fs.stat(dir, (er, st) => {
    if (er || !st.isDirectory())
      er = new CwdError(dir, er && er.code || 'ENOTDIR')
    cb(er)
  })
}

module.exports = (dir, opt, cb) => {
  dir = normPath(dir)

=======
const mkdir = module.exports = (dir, opt, cb) => {
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
<<<<<<< HEAD
  const cwd = normPath(opt.cwd)
=======
  const cwd = opt.cwd
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93

  const done = (er, created) => {
    if (er)
      cb(er)
    else {
<<<<<<< HEAD
      cSet(cache, dir, true)
=======
      cache.set(dir, true)
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
      if (created && doChown)
        chownr(created, uid, gid, er => done(er))
      else if (needChmod)
        fs.chmod(dir, mode, cb)
      else
        cb()
    }
  }

<<<<<<< HEAD
  if (cache && cGet(cache, dir) === true)
    return done()

  if (dir === cwd)
    return checkCwd(dir, done)
=======
  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd)
    return fs.stat(dir, (er, st) => {
      if (er || !st.isDirectory())
        er = new CwdError(dir, er && er.code || 'ENOTDIR')
      done(er)
    })
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93

  if (preserve)
    return mkdirp(dir, mode, done)

<<<<<<< HEAD
  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
=======
  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
}

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length)
    return cb(null, created)
  const p = parts.shift()
<<<<<<< HEAD
  const part = normPath(path.resolve(base + '/' + p))
  if (cGet(cache, part))
=======
  const part = base + '/' + p
  if (cache.get(part))
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
}

const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
  if (er) {
<<<<<<< HEAD
    fs.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normPath(statEr.path)
        cb(statEr)
      } else if (st.isDirectory())
=======
    if (er.path && path.dirname(er.path) === cwd &&
        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
      return cb(new CwdError(cwd, er.code))

    fs.lstat(part, (statEr, st) => {
      if (statEr)
        cb(statEr)
      else if (st.isDirectory())
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
      else if (unlink)
        fs.unlink(part, er => {
          if (er)
            return cb(er)
          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
        })
      else if (st.isSymbolicLink())
        return cb(new SymlinkError(part, part + '/' + parts.join('/')))
      else
        cb(er)
    })
  } else {
    created = created || part
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
}

<<<<<<< HEAD
const checkCwdSync = dir => {
  let ok = false
  let code = 'ENOTDIR'
  try {
    ok = fs.statSync(dir).isDirectory()
  } catch (er) {
    code = er.code
  } finally {
    if (!ok)
      throw new CwdError(dir, code)
  }
}

module.exports.sync = (dir, opt) => {
  dir = normPath(dir)
=======
const mkdirSync = module.exports.sync = (dir, opt) => {
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
<<<<<<< HEAD
  const cwd = normPath(opt.cwd)

  const done = (created) => {
    cSet(cache, dir, true)
=======
  const cwd = opt.cwd

  const done = (created) => {
    cache.set(dir, true)
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
    if (created && doChown)
      chownr.sync(created, uid, gid)
    if (needChmod)
      fs.chmodSync(dir, mode)
  }

<<<<<<< HEAD
  if (cache && cGet(cache, dir) === true)
    return done()

  if (dir === cwd) {
    checkCwdSync(cwd)
    return done()
=======
  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd) {
    let ok = false
    let code = 'ENOTDIR'
    try {
      ok = fs.statSync(dir).isDirectory()
    } catch (er) {
      code = er.code
    } finally {
      if (!ok)
        throw new CwdError(dir, code)
    }
    done()
    return
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
  }

  if (preserve)
    return done(mkdirp.sync(dir, mode))

<<<<<<< HEAD
  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
  let created = null
  for (let p = parts.shift(), part = cwd;
    p && (part += '/' + p);
    p = parts.shift()) {
    part = normPath(path.resolve(part))
    if (cGet(cache, part))
=======
  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
  let created = null
  for (let p = parts.shift(), part = cwd;
       p && (part += '/' + p);
       p = parts.shift()) {

    if (cache.get(part))
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
      continue

    try {
      fs.mkdirSync(part, mode)
      created = created || part
<<<<<<< HEAD
      cSet(cache, part, true)
    } catch (er) {
      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cSet(cache, part, true)
=======
      cache.set(part, true)
    } catch (er) {
      if (er.path && path.dirname(er.path) === cwd &&
          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
        return new CwdError(cwd, er.code)

      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cache.set(part, true)
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
        continue
      } else if (unlink) {
        fs.unlinkSync(part)
        fs.mkdirSync(part, mode)
        created = created || part
<<<<<<< HEAD
        cSet(cache, part, true)
=======
        cache.set(part, true)
>>>>>>> dae208abe6f6ef4a6073d4d46e50d394ac8b0f93
        continue
      } else if (st.isSymbolicLink())
        return new SymlinkError(part, part + '/' + parts.join('/'))
    }
  }

  return done(created)
}
